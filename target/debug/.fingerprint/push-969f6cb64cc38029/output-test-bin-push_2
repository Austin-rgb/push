{"$message_type":"diagnostic","message":"expected `{closure@main2.rs:40:28}` to return `Result<Response<()>, Response<Option<String>>>`, but it returns `Result<Response<()>, Response<()>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/bin/main2.rs","byte_start":1103,"byte_end":1137,"line_start":40,"line_end":40,"column_start":28,"column_end":62,"is_primary":false,"text":[{"text":"            let callback = |req: &Request, mut res: Response| {","highlight_start":28,"highlight_end":62}],"label":"this closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1432,"byte_end":1440,"line_start":49,"line_end":49,"column_start":47,"column_end":55,"is_primary":false,"text":[{"text":"            let ws = accept_hdr_async(stream, callback).await;","highlight_start":47,"highlight_end":55}],"label":"closure used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1156,"byte_end":1369,"line_start":41,"line_end":46,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if let Some(username) = extract_username(req) {","highlight_start":17,"highlight_end":64},{"text":"                    Ok(res)","highlight_start":1,"highlight_end":28},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    *res.status_mut() = StatusCode::UNAUTHORIZED;","highlight_start":1,"highlight_end":66},{"text":"                    Err(res)","highlight_start":1,"highlight_end":29},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":"expected `Result<Response<()>, Response<...>>`, found `Result<Response<()>, Response<()>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1407,"byte_end":1423,"line_start":49,"line_end":49,"column_start":22,"column_end":38,"is_primary":false,"text":[{"text":"            let ws = accept_hdr_async(stream, callback).await;","highlight_start":22,"highlight_end":38}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Result<_, Response<std::option::Option<std::string::String>>>`\n   found enum `Result<_, Response<()>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `{closure@src/bin/main2.rs:40:28: 40:62}` to implement `Callback`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `accept_hdr_async`","code":null,"level":"note","spans":[{"file_name":"/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs","byte_start":5222,"byte_end":5238,"line_start":153,"line_end":153,"column_start":14,"column_end":30,"is_primary":false,"text":[{"text":"pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>","highlight_start":14,"highlight_end":30}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs","byte_start":5360,"byte_end":5368,"line_start":156,"line_end":156,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"    C: Callback + Unpin,","highlight_start":8,"highlight_end":16}],"label":"required by this bound in `accept_hdr_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0271]\u001b[0m\u001b[1m: expected `{closure@main2.rs:40:28}` to return `Result<Response<()>, Response<Option<String>>>`, but it returns `Result<Response<()>, Response<()>>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/bin/main2.rs:41:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let callback = |req: &Request, mut res: Response| {\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[94m----------------------------------\u001b[0m \u001b[1m\u001b[94mthis closure\u001b[0m\n \u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                 if let Some(username) = extract_username(req) {\n \u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     Ok(res)\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 } else {\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     *res.status_mut() = StatusCode::UNAUTHORIZED;\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     Err(res)\n \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_________________^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Response<()>, Response<...>>`, found `Result<Response<()>, Response<()>>`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let ws = accept_hdr_async(stream, callback).await;\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m----------------\u001b[0m         \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mclosure used here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `Result<_, Response<\u001b[1m\u001b[35mstd::option::Option<std::string::String>\u001b[0m>>`\n               found enum `Result<_, Response<\u001b[1m\u001b[35m()\u001b[0m>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `{closure@src/bin/main2.rs:40:28: 40:62}` to implement `Callback`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `accept_hdr_async`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs:156:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     C: Callback + Unpin,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `accept_hdr_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `{closure@main2.rs:40:28}` to return `Result<Response<()>, Response<Option<String>>>`, but it returns `Result<Response<()>, Response<()>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/bin/main2.rs","byte_start":1103,"byte_end":1137,"line_start":40,"line_end":40,"column_start":28,"column_end":62,"is_primary":false,"text":[{"text":"            let callback = |req: &Request, mut res: Response| {","highlight_start":28,"highlight_end":62}],"label":"this closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1407,"byte_end":1441,"line_start":49,"line_end":49,"column_start":22,"column_end":56,"is_primary":false,"text":[{"text":"            let ws = accept_hdr_async(stream, callback).await;","highlight_start":22,"highlight_end":56}],"label":"closure used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1156,"byte_end":1369,"line_start":41,"line_end":46,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if let Some(username) = extract_username(req) {","highlight_start":17,"highlight_end":64},{"text":"                    Ok(res)","highlight_start":1,"highlight_end":28},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    *res.status_mut() = StatusCode::UNAUTHORIZED;","highlight_start":1,"highlight_end":66},{"text":"                    Err(res)","highlight_start":1,"highlight_end":29},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":"expected `Result<Response<()>, Response<...>>`, found `Result<Response<()>, Response<()>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Result<_, Response<std::option::Option<std::string::String>>>`\n   found enum `Result<_, Response<()>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `{closure@src/bin/main2.rs:40:28: 40:62}` to implement `Callback`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `accept_hdr_async`","code":null,"level":"note","spans":[{"file_name":"/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs","byte_start":5222,"byte_end":5238,"line_start":153,"line_end":153,"column_start":14,"column_end":30,"is_primary":false,"text":[{"text":"pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>","highlight_start":14,"highlight_end":30}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs","byte_start":5360,"byte_end":5368,"line_start":156,"line_end":156,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"    C: Callback + Unpin,","highlight_start":8,"highlight_end":16}],"label":"required by this bound in `accept_hdr_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0271]\u001b[0m\u001b[1m: expected `{closure@main2.rs:40:28}` to return `Result<Response<()>, Response<Option<String>>>`, but it returns `Result<Response<()>, Response<()>>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/bin/main2.rs:41:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let callback = |req: &Request, mut res: Response| {\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[94m----------------------------------\u001b[0m \u001b[1m\u001b[94mthis closure\u001b[0m\n \u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                 if let Some(username) = extract_username(req) {\n \u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     Ok(res)\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 } else {\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     *res.status_mut() = StatusCode::UNAUTHORIZED;\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     Err(res)\n \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_________________^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Response<()>, Response<...>>`, found `Result<Response<()>, Response<()>>`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let ws = accept_hdr_async(stream, callback).await;\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m----------------------------------\u001b[0m \u001b[1m\u001b[94mclosure used here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `Result<_, Response<\u001b[1m\u001b[35mstd::option::Option<std::string::String>\u001b[0m>>`\n               found enum `Result<_, Response<\u001b[1m\u001b[35m()\u001b[0m>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `{closure@src/bin/main2.rs:40:28: 40:62}` to implement `Callback`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `accept_hdr_async`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs:156:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     C: Callback + Unpin,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `accept_hdr_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected `{closure@main2.rs:40:28}` to return `Result<Response<()>, Response<Option<String>>>`, but it returns `Result<Response<()>, Response<()>>`","code":{"code":"E0271","explanation":"A type mismatched an associated type of a trait.\n\nErroneous code example:\n\n```compile_fail,E0271\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n//                        |            |\n//         This says `foo` can         |\n//           only be used with         |\n//              some type that         |\n//         implements `Trait`.         |\n//                                     |\n//                             This says not only must\n//                             `T` be an impl of `Trait`\n//                             but also that the impl\n//                             must assign the type `u32`\n//                             to the associated type.\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//      |                             |\n// `i8` does have                     |\n// implementation                     |\n// of `Trait`...                      |\n//                     ... but it is an implementation\n//                     that assigns `&'static str` to\n//                     the associated type.\n\nfoo(3_i8);\n// Here, we invoke `foo` with an `i8`, which does not satisfy\n// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n// therefore the type-checker complains with this error code.\n```\n\nThe issue can be resolved by changing the associated type:\n1) in the `foo` implementation:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = &'static str; }\n\nfoo(3_i8);\n```\n\n2) in the `Trait` implementation for `i8`:\n```\ntrait Trait { type AssociatedType; }\n\nfn foo<T>(t: T) where T: Trait<AssociatedType = u32> {\n    println!(\"in foo\");\n}\n\nimpl Trait for i8 { type AssociatedType = u32; }\n\nfoo(3_i8);\n```\n"},"level":"error","spans":[{"file_name":"src/bin/main2.rs","byte_start":1103,"byte_end":1137,"line_start":40,"line_end":40,"column_start":28,"column_end":62,"is_primary":false,"text":[{"text":"            let callback = |req: &Request, mut res: Response| {","highlight_start":28,"highlight_end":62}],"label":"this closure","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1442,"byte_end":1447,"line_start":49,"line_end":49,"column_start":57,"column_end":62,"is_primary":false,"text":[{"text":"            let ws = accept_hdr_async(stream, callback).await;","highlight_start":57,"highlight_end":62}],"label":"closure used here","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/bin/main2.rs","byte_start":1442,"byte_end":1447,"line_start":49,"line_end":49,"column_start":57,"column_end":62,"is_primary":false,"text":[{"text":"            let ws = accept_hdr_async(stream, callback).await;","highlight_start":57,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of `await` expression","def_site_span":{"file_name":"src/bin/main2.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/bin/main2.rs","byte_start":1156,"byte_end":1369,"line_start":41,"line_end":46,"column_start":17,"column_end":18,"is_primary":true,"text":[{"text":"                if let Some(username) = extract_username(req) {","highlight_start":17,"highlight_end":64},{"text":"                    Ok(res)","highlight_start":1,"highlight_end":28},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                    *res.status_mut() = StatusCode::UNAUTHORIZED;","highlight_start":1,"highlight_end":66},{"text":"                    Err(res)","highlight_start":1,"highlight_end":29},{"text":"                }","highlight_start":1,"highlight_end":18}],"label":"expected `Result<Response<()>, Response<...>>`, found `Result<Response<()>, Response<()>>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Result<_, Response<std::option::Option<std::string::String>>>`\n   found enum `Result<_, Response<()>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `{closure@src/bin/main2.rs:40:28: 40:62}` to implement `Callback`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `accept_hdr_async`","code":null,"level":"note","spans":[{"file_name":"/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs","byte_start":5222,"byte_end":5238,"line_start":153,"line_end":153,"column_start":14,"column_end":30,"is_primary":false,"text":[{"text":"pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>","highlight_start":14,"highlight_end":30}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs","byte_start":5360,"byte_end":5368,"line_start":156,"line_end":156,"column_start":8,"column_end":16,"is_primary":true,"text":[{"text":"    C: Callback + Unpin,","highlight_start":8,"highlight_end":16}],"label":"required by this bound in `accept_hdr_async`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0271]\u001b[0m\u001b[1m: expected `{closure@main2.rs:40:28}` to return `Result<Response<()>, Response<Option<String>>>`, but it returns `Result<Response<()>, Response<()>>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/bin/main2.rs:41:17\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m40\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let callback = |req: &Request, mut res: Response| {\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[94m----------------------------------\u001b[0m \u001b[1m\u001b[94mthis closure\u001b[0m\n \u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m                 if let Some(username) = extract_username(req) {\n \u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     Ok(res)\n \u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 } else {\n \u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     *res.status_mut() = StatusCode::UNAUTHORIZED;\n \u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                     Err(res)\n \u001b[1m\u001b[94m46\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 }\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|_________________^\u001b[0m \u001b[1m\u001b[91mexpected `Result<Response<()>, Response<...>>`, found `Result<Response<()>, Response<()>>`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n \u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let ws = accept_hdr_async(stream, callback).await;\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94mclosure used here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected enum `Result<_, Response<\u001b[1m\u001b[35mstd::option::Option<std::string::String>\u001b[0m>>`\n               found enum `Result<_, Response<\u001b[1m\u001b[35m()\u001b[0m>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `{closure@src/bin/main2.rs:40:28: 40:62}` to implement `Callback`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `accept_hdr_async`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/anomalous/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/tokio-tungstenite-0.21.0/src/lib.rs:156:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m153\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub async fn accept_hdr_async<S, C>(stream: S, callback: C) -> Result<WebSocketStream<S>, WsError>\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----------------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m156\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     C: Callback + Unpin,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `accept_hdr_async`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `protocol` found for reference `&tokio::net::TcpStream` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/bin/main2.rs","byte_start":1775,"byte_end":1822,"line_start":60,"line_end":62,"column_start":28,"column_end":18,"is_primary":false,"text":[{"text":"            let username = ws","highlight_start":28,"highlight_end":30},{"text":"                .get_ref()","highlight_start":1,"highlight_end":27},{"text":"                .protocol()","highlight_start":1,"highlight_end":18}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1822,"byte_end":1830,"line_start":62,"line_end":62,"column_start":18,"column_end":26,"is_primary":true,"text":[{"text":"                .protocol()","highlight_start":18,"highlight_end":26}],"label":"method not found in `&tokio::net::TcpStream`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `protocol` found for reference `&tokio::net::TcpStream` in the current scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/bin/main2.rs:62:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m60\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               let username = ws\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________________-\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .get_ref()\n\u001b[1m\u001b[94m62\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .protocol()\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `&tokio::net::TcpStream`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________________|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/bin/main2.rs","byte_start":1858,"byte_end":1859,"line_start":63,"line_end":63,"column_start":26,"column_end":27,"is_primary":false,"text":[{"text":"                .map(|p| p.to_string())","highlight_start":26,"highlight_end":27}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/bin/main2.rs","byte_start":1855,"byte_end":1856,"line_start":63,"line_end":63,"column_start":23,"column_end":24,"is_primary":true,"text":[{"text":"                .map(|p| p.to_string())","highlight_start":23,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/bin/main2.rs","byte_start":1856,"byte_end":1856,"line_start":63,"line_end":63,"column_start":24,"column_end":24,"is_primary":true,"text":[{"text":"                .map(|p| p.to_string())","highlight_start":24,"highlight_end":24}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/bin/main2.rs:63:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 .map(|p| p.to_string())\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m63\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                .map(|p\u001b[92m: /* Type */\u001b[0m| p.to_string())\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 5 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 5 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0271, E0282, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0271, E0282, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0271`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0271`.\u001b[0m\n"}
